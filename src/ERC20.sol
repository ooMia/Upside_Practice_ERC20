// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import {_ERC20, _IERC2612} from "./Custom.sol";

contract ERC20 is _ERC20, _IERC2612 {
    bytes32 constant PERMIT_HASH =
        keccak256(
            "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
        );

    // https://eips.ethereum.org/EIPS/eip-2612#specification
    bytes32 immutable DOMAIN_SEPARATOR =
        keccak256(
            abi.encode(
                keccak256(
                    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
                ),
                keccak256(bytes("UPSIDE")),
                keccak256(bytes("1")),
                block.chainid,
                address(this)
            )
        );

    mapping(address => uint) public nonce;

    constructor(
        string memory _name,
        string memory _symbol
    ) _ERC20(_name, _symbol) {}

    modifier statusModifier(address caller) {
        require(health);
        _;
        ++nonce[caller];
    }

    // ===== ERC20 with nonces =====

    function transfer(
        address to,
        uint256 amount
    ) external override statusModifier(msg.sender) returns (bool) {
        bool res = balances[msg.sender] >= amount;
        if (res) {
            balances[msg.sender] -= amount;
            balances[to] += amount;
        }
        emit Transfer(msg.sender, to, amount);
        return res;
    }

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external override statusModifier(msg.sender) returns (bool) {
        bool res = (balances[from] >= amount) &&
            (allowances[from][msg.sender] >= amount);
        if (res) {
            balances[from] -= amount;
            balances[to] += amount;
            allowances[from][msg.sender] -= amount;
        }
        emit Transfer(from, to, amount);
        return res;
    }

    function approve(
        address spender,
        uint256 amount
    ) external override returns (bool) {
        return approveFrom(msg.sender, spender, amount);
    }

    // ===== ERC20 extensions with permit =====
    function approveFrom(
        address owner,
        address spender,
        uint256 amount
    ) public statusModifier(owner) returns (bool) {
        bool res = (balances[owner] >= amount);
        if (res) {
            allowances[owner][spender] += amount;
        }
        emit Approval(owner, spender, amount);
        return res;
    }

    // ===== ERC2612 =====

    // v, r, s are the signature of the owner which is generated by the owner's private key with secp256k1 curve
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external override statusModifier(msg.sender) {
        require(block.timestamp <= deadline, "Permit expired");
        bytes32 structHash = keccak256(
            abi.encode(
                PERMIT_HASH,
                owner,
                spender,
                value,
                nonce[owner],
                deadline
            )
        );
        bytes32 digest = _toTypedDataHash(structHash);
        address signer = ecrecover(digest, v, r, s);
        require(signer == owner, "INVALID_SIGNER");
        approveFrom(owner, spender, value);
    }

    // ==== ERC2612 Views ====

    function nonces(address owner) external view override returns (uint256) {
        return nonce[owner];
    }

    // DOMAIN_SEPARATOR(Optional)
    function _toTypedDataHash(
        bytes32 structHash
    ) public view override returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(bytes("Mia"), DOMAIN_SEPARATOR, structHash)
            );
    }
}
